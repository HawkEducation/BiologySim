<!DOCTYPE html>
<html>
<head>
    <style>
        body { background: #0a1205; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: 'Courier New', Courier, monospace; color: #aaffaa; }
        #main-container { display: flex; gap: 10px; border: 2px solid #2d4c1e; padding: 10px; background: #0f1a09; }
        canvas { image-rendering: pixelated; background: #1a2e12; border: 1px solid #3d6a26; }
        #log-container { width: 260px; height: 500px; background: #050a03; border: 1px solid #2d4c1e; font-size: 11px; overflow: hidden; display: flex; flex-direction: column-reverse; color: #ccffcc; }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #1a2e12; padding: 2px; }
        .elemental { color: #5dade2; font-weight: bold; }
    </style>
</head>
<body>

<div id="main-container">
    <canvas id="simCanvas" width="640" height="480"></canvas>
    <div id="log-container"></div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log-container');

const CELL_SIZE = 16; 
const COLS = 40; 
const ROWS = 30;

let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(null));
let creatures = [];
let tickCount = 0;
let isWetSeason = true;

function addLog(text, type) {
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerText = `> ${text}`;
    logEl.prepend(entry);
    if (logEl.children.length > 20) logEl.removeChild(logEl.lastChild);
}

class Creature {
    constructor(gx, gy, char, color) {
        this.gx = gx; this.gy = gy;
        this.char = char; this.baseColor = color; this.color = color;
        this.energy = (char === 'V') ? 300 : (char === 'P' ? 450 : 180);
        this.isDamp = false; this.moveCooldown = 0;
        grid[gx][gy] = this;
    }

    move() {
        if (this.moveCooldown > 0) { this.moveCooldown--; return; }
        
        // Air interaction
        let inAir = this.scan(0, (i) => i.char === '"');
        if (inAir) this.isDamp = true; // Air (Steam) dampens the creature

        let fire = this.scan(2, (i) => i.char === '!');
        if (fire) {
            if (this.isDamp) {
                this.isDamp = false; // Shield used
                addLog(this.char + " shield used!", "elemental");
            } else {
                let dx = this.gx > fire.gx ? 1 : -1;
                let dy = this.gy > fire.gy ? 1 : -1;
                this.updatePos(Math.max(0, Math.min(COLS-1, this.gx+dx)), Math.max(0, Math.min(ROWS-1, this.gy+dy)));
                return;
            }
        }
        
        this.energy -= (this.char === 'V' ? 1.1 : 0.3);
        if (this.isDamp) this.color = "#00ffff"; else this.color = this.baseColor;

        if (this.energy <= 0) { this.die(); return; }

        let tx = Math.max(0, Math.min(COLS - 1, this.gx + (Math.floor(Math.random() * 3) - 1)));
        let ty = Math.max(0, Math.min(ROWS - 1, this.gy + (Math.floor(Math.random() * 3) - 1)));
        const occupant = grid[tx][ty];

        if (!occupant || ['v', 'f', '~', '#', '!', '%', 'T', '"', '.'].includes(occupant.char)) {
            if (occupant && occupant.char === '!' && !this.isDamp) { this.die(); return; }
            this.updatePos(tx, ty, occupant);
        }
    }

    die() {
        grid[this.gx][this.gy] = { char: '#', color: '#554433', timer: 80 };
        creatures = creatures.filter(c => c !== this);
    }

    scan(dist, check) {
        for (let x = -dist; x <= dist; x++) {
            for (let y = -dist; y <= dist; y++) {
                let nx = this.gx + x, ny = this.gy + y;
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && grid[nx][ny] && check(grid[nx][ny])) return {gx:nx, gy:ny};
            }
        }
        return null;
    }

    updatePos(nx, ny, occupant) {
        grid[this.gx][this.gy] = (this.standingOn && ['v','f','%','T','"', '.'].includes(this.standingOn.char)) ? this.standingOn : null;
        this.gx = nx; this.gy = ny;
        this.standingOn = (occupant && ['v','f','%','T','"', '.'].includes(occupant.char)) ? occupant : null;
        grid[this.gx][this.gy] = this;
    }
}

function handleEnvironment() {
    tickCount++;
    if (tickCount % 500 === 0) {
        isWetSeason = !isWetSeason;
        addLog(isWetSeason ? "WET SEASON" : "DRY SEASON", "elemental");
    }

    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let cell = grid[x][y];
            if (!cell) continue;

            // Fire + Water/Rain = Air
            if (cell.char === '!' && isWetSeason && Math.random() < 0.2) {
                grid[x][y] = { char: '"', color: '#ffffff', timer: 12 };
            }

            if (cell.char === '"' || cell.char === '%' || cell.char === '~' || cell.char === '#') {
                cell.timer -= 1;
                if (cell.timer <= 0) grid[x][y] = { char: '.', color: '#444' }; // Return to Rock
            }

            if (cell.char === '!') {
                cell.timer--;
                if (cell.timer <= 0) grid[x][y] = { char: '%', color: '#555', timer: 60 };
            }
        }
    }

    // Rock spawning vines or trees
    if (Math.random() < (isWetSeason ? 0.08 : 0.02)) {
        let rx = Math.floor(Math.random()*COLS), ry = Math.floor(Math.random()*ROWS);
        if (!grid[rx][ry] || grid[rx][ry].char === '.') {
            grid[rx][ry] = { char: (Math.random() < 0.1 ? 'T' : 'v'), color: (Math.random() < 0.1 ? '#3d6a26' : '#2ecc71') };
        }
    }
}

function init() {
    for(let i=0; i<400; i++) grid[Math.floor(Math.random()*COLS)][Math.floor(Math.random()*ROWS)] = { char: '.', color: '#444' };
    for(let i=0; i<15; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'B', '#fff'));
    for(let i=0; i<4; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'V', '#aaa'));
    for(let i=0; i<8; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'H', '#90ee90'));
}

function tick() {
    handleEnvironment();
    creatures.forEach(c => c.move());
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${CELL_SIZE}px monospace`;
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let item = grid[x][y];
            if (item) {
                ctx.fillStyle = item.color || '#2ecc71';
                ctx.fillText(item.char, x * CELL_SIZE, y * CELL_SIZE + (CELL_SIZE * 0.8));
            }
        }
    }
    setTimeout(tick, 100);
}
init(); tick();
</script>
</body>
</html>
