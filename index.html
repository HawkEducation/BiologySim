<!DOCTYPE html>
<html>
<head>
    <style>
        body { background: #0a1205; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: 'Courier New', Courier, monospace; color: #aaffaa; }
        #main-container { display: flex; gap: 10px; border: 2px solid #2d4c1e; padding: 10px; background: #0f1a09; position: relative; }
        canvas { image-rendering: pixelated; background: #1a2e12; border: 1px solid #3d6a26; }
        #ui-top { position: absolute; top: -45px; left: 0; width: 100%; display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 14px; }
        #log-container { width: 260px; height: 500px; background: #050a03; border: 1px solid #2d4c1e; font-size: 11px; overflow: hidden; display: flex; flex-direction: column-reverse; color: #ccffcc; }
        button { background: #1a2e12; color: #aaffaa; border: 1px solid #3d6a26; cursor: pointer; padding: 4px 10px; font-family: inherit; }
        button.active { background: #ff4444; color: #000; font-weight: bold; }
        .stat-box { margin-left: 15px; color: #00ffff; }
    </style>
</head>
<body>
<div id="main-container">
    <div id="ui-top">
        <div>
            <button id="toggle-play" onclick="togglePlay()">PLAY MODE: OFF</button>
            <span id="energy-ui" class="stat-box" style="display:none;">ENERGY: 400</span>
            <span id="rock-ui" class="stat-box" style="display:none;">ROCKS: 10/50</span>
        </div>
        <span id="season-ui">SEASON: WET</span>
    </div>
    <canvas id="simCanvas" width="640" height="480"></canvas>
    <div id="log-container"></div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log-container');

const CELL_SIZE = 16; 
const COLS = 40; 
const ROWS = 30;

let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(null));
let creatures = [];
let player = null;
let tickCount = 0;
let isWetSeason = true;
let isPlayMode = false;
let lastDir = {x: 0, y: 1};
let sentries = [];
let beacons = [];
let gardens = [];
let muzzleFlashes = [];
let hasAutoPicker = false;
let energyCap = 600;
let rockCap = 50;

function togglePlay() {
    isPlayMode = !isPlayMode;
    const btn = document.getElementById('toggle-play');
    if (isPlayMode) {
        btn.innerText = "PLAY MODE: ON"; btn.classList.add('active');
        document.getElementById('energy-ui').style.display = "inline";
        document.getElementById('rock-ui').style.display = "inline";
        spawnPlayer();
        addLog("Update #14: The Oasis Update! Build the 41-Rock Fortress.");
    } else {
        btn.innerText = "PLAY MODE: OFF"; btn.classList.remove('active');
        document.getElementById('energy-ui').style.display = "none";
        document.getElementById('rock-ui').style.display = "none";
        removePlayer();
    }
}

function spawnPlayer() {
    player = new Player(20, 25);
    sentries = []; beacons = []; gardens = []; muzzleFlashes = [];
    hasAutoPicker = false; energyCap = 600;
}

function removePlayer() { if (player) { grid[player.gx][player.gy] = player.standingOn || { char: '.', color: '#444' }; player = null; } }

function addLog(text) {
    const entry = document.createElement('div');
    entry.innerText = `> ${text}`;
    logEl.prepend(entry);
    if (logEl.children.length > 20) logEl.removeChild(logEl.lastChild);
}

class Entity {
    constructor(gx, gy, char, color) {
        this.gx = gx; this.gy = gy;
        this.char = char; this.color = color;
        this.energy = 200; this.standingOn = grid[gx][gy];
        grid[gx][gy] = this;
    }
    updatePos(nx, ny) {
        let occ = grid[nx][ny];
        if (this.char !== 'p' && occ && ['W','O','D','R','B','A'].includes(occ.char)) return;
        grid[this.gx][this.gy] = (this.standingOn && ['y','v','f','%','T','"', '.', 'W', '|', 'D', 'O','#','$', 'G', 'X', 'R','B','A','e'].includes(this.standingOn.char)) ? this.standingOn : { char: '.', color: '#444' };
        this.gx = nx; this.gy = ny;
        this.standingOn = (occ && ['y','v','f','%','T','"', '.', 'W', '|', 'D', 'O','#','$', 'G', 'X', 'R','B','A','e'].includes(occ.char)) ? occ : { char: '.', color: '#444' };
        grid[this.gx][this.gy] = this;
    }
}

class Player extends Entity {
    constructor(gx, gy) { super(gx, gy, 'p', '#ff4444'); this.energy = 400; this.rocks = 10; }
    handleInput(key) {
        let k = key.toLowerCase();
        if (k === "a") { this.buildSentry(); return; }
        if (k === "t") { this.buildMasterCastle(); return; }
        if (k === "f") { this.flingRock(); return; }
        
        let dx = 0, dy = 0;
        if (key === "ArrowUp") dy = -1; if (key === "ArrowDown") dy = 1;
        if (key === "ArrowLeft") dx = -1; if (key === "ArrowRight") dx = 1;
        
        if (dx !== 0 || dy !== 0) {
            lastDir = {x: dx, y: dy};
            let nx = Math.max(0, Math.min(COLS - 1, this.gx + dx));
            let ny = Math.max(0, Math.min(ROWS - 1, this.gy + dy));
            let target = grid[nx][ny];
            if (target && target.char === '.') { 
                if (this.rocks < rockCap) { this.rocks++; grid[nx][ny] = { char: ' ', color: '#000' }; } 
            }
            if (target instanceof NPC || (target && target.char === '#')) { 
                this.energy = Math.min(energyCap, this.energy + 150); 
                if (target instanceof NPC) creatures = creatures.filter(c => c !== target);
                else grid[nx][ny] = { char: '.', color: '#444' };
            }
            this.updatePos(nx, ny);
        }
    }
    buildSentry() {
        if (this.rocks >= 25) { this.rocks -= 25; this.standingOn = { char: 'A', color: '#ff00ff' }; sentries.push({x: this.gx, y: this.gy}); addLog("Sentry Online."); }
        else { addLog(`Need ${25 - this.rocks} more rocks.`); }
    }
    buildMasterCastle() {
        if (this.rocks >= 41) {
            this.rocks -= 41;
            const master = [
                [null, 'O', 'O', 'O', null],
                ['O', 'W', 'e', 'W', 'O'],
                ['O', 'W', '|', 'W', 'O'],
                ['O', 'B', 'D', 'W', 'O'],
                [null, 'O', null, 'O', null]
            ];
            this.applyBlueprint(this.gx, this.gy, master, 5, 5);
            addLog("The Oasis Fortress is complete. Gardens sprouting...");
            hasAutoPicker = true;
            // Sprout 3 gardens nearby
            for(let i=0; i<3; i++) {
                let gx = this.gx + (Math.floor(Math.random()*7)-3);
                let gy = this.gy + (Math.floor(Math.random()*7)-3);
                if(gx >=0 && gx < COLS && gy >=0 && gy < ROWS && grid[gx][gy].char === '.') {
                    grid[gx][gy] = { char: '%', color: '#2d5a27' };
                    gardens.push({x: gx, y: gy});
                }
            }
        } else {
            addLog(`Need ${41 - this.rocks} more rocks!`);
        }
    }
    applyBlueprint(cx, cy, bp, w, h) {
        let ox = Math.floor(w/2), oy = Math.floor(h/2);
        for(let j=0; j<h; j++) for(let i=0; i<w; i++) {
            let tx = cx - ox + i, ty = cy - oy + j;
            if (tx >=0 && tx < COLS && ty >=0 && ty < ROWS && bp[j][i]) {
                let type = bp[j][i];
                let col = type === 'W' ? '#8B4513' : (type === '|' ? '#00ffff' : (type === 'B' ? '#fff' : (type === 'e' ? '#ff0' : (type === 'D' ? '#A52A2A' : '#888'))));
                grid[tx][ty] = { char: type, color: col };
                if (type === 'B') beacons.push({x: tx, y: ty});
            }
        }
    }
    flingRock() {
        if (this.rocks > 0) {
            this.rocks--; let tx = this.gx + lastDir.x, ty = this.gy + lastDir.y;
            while (tx >= 0 && tx < COLS && ty >= 0 && ty < ROWS) {
                let hit = grid[tx][ty];
                if (hit instanceof NPC) { hit.die(); return; }
                if (hit && ['O','W','A'].includes(hit.char)) break;
                tx += lastDir.x; ty += lastDir.y;
            }
        }
    }
    die() { addLog("The Oasis has fallen."); this.energy = 0; togglePlay(); }
}

class NPC extends Entity {
    move() {
        this.energy -= 0.4; if (this.energy <= 0) this.die();
        let nx = Math.max(0, Math.min(COLS - 1, this.gx + (Math.floor(Math.random() * 3) - 1)));
        let ny = Math.max(0, Math.min(ROWS - 1, this.gy + (Math.floor(Math.random() * 3) - 1)));
        this.updatePos(nx, ny);
    }
    die() { grid[this.gx][this.gy] = { char: '#', color: '#ffcc00', timer: 120 }; creatures = creatures.filter(c => c !== this); }
}

function handleEnvironment() {
    tickCount++;
    if (tickCount % 500 === 0) isWetSeason = !isWetSeason;
    document.getElementById('season-ui').innerText = "SEASON: " + (isWetSeason ? "WET" : "DRY");

    // Garden Growth
    if (tickCount % 150 === 0) {
        gardens.forEach(g => {
            if (Math.random() < 0.3) {
                // Drop food next to garden
                let rx = g.x + (Math.floor(Math.random()*3)-1);
                let ry = g.y + (Math.floor(Math.random()*3)-1);
                if (rx >= 0 && rx < COLS && ry >= 0 && ry < ROWS && grid[rx][ry].char === '.') {
                    grid[rx][ry] = { char: '#', color: '#ffcc00' };
                }
            }
        });
    }

    if (tickCount % 20 === 0 && player) {
        for(let x=0; x<COLS; x++) for(let y=0; y<ROWS; y++) {
            let cell = grid[x][y];
            if (cell instanceof NPC) {
                let shooter = sentries.find(s => Math.sqrt((x-s.x)**2 + (y-s.y)**2) < 6);
                if (shooter) { cell.die(); muzzleFlashes.push({x: shooter.x, y: shooter.y, life: 3}); continue; }
            }
            if (hasAutoPicker && cell?.char === '#') {
                if (Math.sqrt((x-player.gx)**2 + (y-player.gy)**2) < 10) { 
                    grid[x][y] = { char: '.', color: '#444' }; 
                    player.energy = Math.min(energyCap, player.energy + 150); 
                }
            }
        }
    }
    muzzleFlashes.forEach(f => f.life--);
    muzzleFlashes = muzzleFlashes.filter(f => f.life > 0);
}

function init() {
    for(let i=0; i<COLS; i++) for(let j=0; j<ROWS; j++) grid[i][j] = { char: '.', color: '#444' };
    for(let i=0; i<25; i++) creatures.push(new NPC(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'm', '#90ee90'));
}

window.addEventListener("keydown", (e) => { if (player) player.handleInput(e.key); });

function tick() {
    if (player) {
        if (player.standingOn?.char === '|') {
            player.energy = Math.min(energyCap, player.energy + 4);
            if (tickCount % 40 === 0 && player.rocks < rockCap) player.rocks++;
        } else { player.energy -= 0.4; }
        document.getElementById('energy-ui').innerText = "ENERGY: " + Math.floor(player.energy);
        document.getElementById('rock-ui').innerText = "ROCKS: " + player.rocks + "/" + rockCap;
        if (player.energy <= 0) player.die();
    }
    handleEnvironment(); creatures.forEach(c => c.move());
    if (creatures.length < 18 && Math.random() < 0.05) creatures.push(new NPC(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'm', '#90ee90'));
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${CELL_SIZE}px monospace`;
    
    beacons.forEach(b => {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + Math.abs(Math.sin(tickCount/5)) * 0.2})`;
        for(let h=1; h<12; h++) {
            if (b.y - h >= 0) ctx.fillText('{}', b.x * CELL_SIZE - 2, (b.y - h) * CELL_SIZE + (CELL_SIZE * 0.8));
        }
    });

    ctx.fillStyle = "#ffff00";
    muzzleFlashes.forEach(f => { ctx.fillText("*", f.x * CELL_SIZE, f.y * CELL_SIZE + (CELL_SIZE * 0.8)); });

    for (let x = 0; x < COLS; x++) for (let y = 0; y < ROWS; y++) {
        let item = grid[x][y];
        if (item) {
            ctx.fillStyle = (item === player && player.standingOn?.char === '|') ? "#fff" : (item.color || '#2ecc71');
            ctx.fillText(item.char, x * CELL_SIZE, y * CELL_SIZE + (CELL_SIZE * 0.8));
        }
    }
    setTimeout(tick, 100);
}
init(); tick();
</script>
</body>
</html>
