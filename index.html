<!DOCTYPE html>
<html>
<head>
    <style>
        body { background: #0a1205; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: 'Courier New', Courier, monospace; color: #aaffaa; }
        #main-container { display: flex; gap: 10px; border: 2px solid #2d4c1e; padding: 10px; background: #0f1a09; position: relative; }
        canvas { image-rendering: pixelated; background: #1a2e12; border: 1px solid #3d6a26; }
        #ui-top { position: absolute; top: -45px; left: 0; width: 100%; display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 14px; }
        #log-container { width: 260px; height: 500px; background: #050a03; border: 1px solid #2d4c1e; font-size: 11px; overflow: hidden; display: flex; flex-direction: column-reverse; color: #ccffcc; }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #1a2e12; padding: 2px; }
        button { background: #1a2e12; color: #aaffaa; border: 1px solid #3d6a26; cursor: pointer; padding: 4px 10px; font-family: inherit; }
        button.active { background: #ff4444; color: #000; font-weight: bold; }
        .stat-box { margin-left: 15px; color: #00ffff; }
    </style>
</head>
<body>
<div id="main-container">
    <div id="ui-top">
        <div>
            <button id="toggle-play" onclick="togglePlay()">PLAY MODE: OFF</button>
            <span id="energy-ui" class="stat-box" style="display:none;">ENERGY: 400</span>
            <span id="rock-ui" class="stat-box" style="display:none;">ROCKS: 0</span>
        </div>
        <span id="season-ui">SEASON: WET</span>
    </div>
    <canvas id="simCanvas" width="640" height="480"></canvas>
    <div id="log-container"></div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log-container');

const CELL_SIZE = 16; 
const COLS = 40; 
const ROWS = 30;

let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(null));
let creatures = [];
let player = null;
let tickCount = 0;
let isWetSeason = true;
let isPlayMode = false;

function togglePlay() {
    isPlayMode = !isPlayMode;
    const btn = document.getElementById('toggle-play');
    const energyDisp = document.getElementById('energy-ui');
    const rockDisp = document.getElementById('rock-ui');
    if (isPlayMode) {
        btn.innerText = "PLAY MODE: ON"; btn.classList.add('active');
        energyDisp.style.display = "inline"; rockDisp.style.display = "inline";
        spawnPlayer();
        addLog("Fortress construction enabled. Find a Tree (T)!");
    } else {
        btn.innerText = "PLAY MODE: OFF"; btn.classList.remove('active');
        energyDisp.style.display = "none"; rockDisp.style.display = "none";
        removePlayer();
    }
}

function spawnPlayer() {
    let attempts = 0;
    while(attempts < 100) {
        let rx = Math.floor(Math.random() * COLS), ry = Math.floor(Math.random() * ROWS);
        if (grid[rx][ry] && grid[rx][ry].char === '.') { player = new Player(rx, ry); break; }
        attempts++;
    }
}

function removePlayer() { if (player) { grid[player.gx][player.gy] = player.standingOn || { char: '.', color: '#444' }; player = null; } }

function addLog(text) {
    const entry = document.createElement('div');
    entry.innerText = `> ${text}`;
    logEl.prepend(entry);
    if (logEl.children.length > 20) logEl.removeChild(logEl.lastChild);
}

class Entity {
    constructor(gx, gy, char, color) {
        this.gx = gx; this.gy = gy;
        this.char = char; this.baseColor = color; this.color = color;
        this.energy = 200; this.standingOn = grid[gx][gy];
        grid[gx][gy] = this;
    }
    updatePos(nx, ny) {
        let occ = grid[nx][ny];
        // Walls and Rocks are solid
        if (occ && (occ.char === 'W' || occ.char === 'O')) return; 
        // Door is only for player
        if (occ && occ.char === 'D' && this.char !== 'p') return;

        grid[this.gx][this.gy] = (this.standingOn && ['y','v','f','%','T','"', '.', 'W', '|', 'D', 'O'].includes(this.standingOn.char)) ? this.standingOn : { char: '.', color: '#444' };
        this.gx = nx; this.gy = ny;
        this.standingOn = (occ && ['y','v','f','%','T','"', '.', 'W', '|', 'D', 'O'].includes(occ.char)) ? occ : { char: '.', color: '#444' };
        grid[this.gx][this.gy] = this;
    }
}

class Player extends Entity {
    constructor(gx, gy) { super(gx, gy, 'p', '#ff4444'); this.energy = 400; this.rocks = 0; }
    handleInput(key) {
        if (key === " ") { this.placeWall(); return; }
        let nx = this.gx, ny = this.gy;
        if (key === "ArrowUp") ny--; if (key === "ArrowDown") ny++;
        if (key === "ArrowLeft") nx--; if (key === "ArrowRight") nx++;
        nx = Math.max(0, Math.min(COLS - 1, nx)); ny = Math.max(0, Math.min(ROWS - 1, ny));
        let target = grid[nx][ny];

        if (target && target.char === '.') {
            if (this.rocks < 10) { this.rocks++; grid[nx][ny] = { char: ' ', color: '#000' }; }
        }
        if (target && target.char === 'T') { this.buildFortress(nx, ny); return; }
        if (target instanceof NPC) { this.energy += 150; addLog("p fed."); creatures = creatures.filter(c => c !== target); }
        if (target && target.char === '!') { this.die(); return; }
        
        this.energy -= 0.5; 
        this.updatePos(nx, ny);
    }
    placeWall() {
        if (this.rocks > 0) {
            this.standingOn = { char: 'O', color: '#888', isRock: true };
            this.rocks--;
            addLog("Reinforced tile.");
        }
    }
    buildFortress(cx, cy) {
        // Blueprint Matrix (5x5 center)
        // . O O O .
        // O W W W O
        // O W | W O
        // . O D O .
        // . . O . .
        const blueprint = [
            [null, 'O', 'O', 'O', null],
            ['O', 'W', 'W', 'W', 'O'],
            ['O', 'W', '|', 'W', 'O'],
            [null, 'O', 'D', 'O', null],
            [null, null, 'O', null, null]
        ];

        if (cx < 2 || cx >= COLS - 2 || cy < 2 || cy >= ROWS - 3) {
            addLog("Not enough space to build!");
            return;
        }

        for(let j = 0; j < 5; j++) {
            for(let i = 0; i < 5; i++) {
                let tx = cx - 2 + i;
                let ty = cy - 2 + j;
                let type = blueprint[j][i];
                if (type) {
                    let color = '#888'; // Default Rock
                    if (type === 'W') color = '#8B4513';
                    if (type === '|') color = '#87CEEB';
                    if (type === 'D') color = '#A52A2A';
                    grid[tx][ty] = { char: type, color: color, burnHeat: 0, isRock: (type === 'O') };
                }
            }
        }
        addLog("Fortress Complete.");
    }
    die() { addLog("p perished."); this.energy = 0; togglePlay(); }
}

class NPC extends Entity {
    move() {
        this.energy -= 0.4; if (this.energy <= 0) { this.die(); return; }
        let moveX = Math.floor(Math.random() * 3) - 1, moveY = Math.floor(Math.random() * 3) - 1;
        let nx = Math.max(0, Math.min(COLS - 1, this.gx + moveX)), ny = Math.max(0, Math.min(ROWS - 1, this.gy + moveY));
        let target = grid[nx][ny];
        // NPCs can't go in Door or hit Walls/Rocks
        if (!target || ['.','y','v'].includes(target.char)) {
            if (target && (target.char === 'y' || target.char === 'v')) this.energy += 30;
            this.updatePos(nx, ny);
        }
    }
    die() {
        if (this.standingOn && this.standingOn.char === 'y') grid[this.gx][this.gy] = { char: 'T', color: '#3d6a26' }; 
        else grid[this.gx][this.gy] = { char: '#', color: '#554433', timer: 50 };
        creatures = creatures.filter(c => c !== this);
    }
}

function handleEnvironment() {
    tickCount++;
    if (tickCount % 400 === 0) isWetSeason = !isWetSeason;
    document.getElementById('season-ui').innerText = "SEASON: " + (isWetSeason ? "WET" : "DRY");

    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let cell = grid[x][y]; if (!cell || cell instanceof Entity) continue;
            if (cell.char === '!') {
                let nx = x + (Math.floor(Math.random()*3)-1), ny = y + (Math.floor(Math.random()*3)-1);
                if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS && grid[nx][ny]) {
                    let t = grid[nx][ny];
                    if (['y','v'].includes(t.char)) grid[nx][ny] = { char: '!', color: '#ff4500', timer: 15 };
                    if (['W', 'T', 'D', '|'].includes(t.char)) {
                        t.burnHeat = (t.burnHeat || 0) + 1;
                        if (t.burnHeat > 25) grid[nx][ny] = { char: '!', color: '#ff4500', timer: 20 };
                    }
                }
                cell.timer--; if (cell.timer <= 0) grid[x][y] = { char: '%', color: '#555', timer: 40 };
            }
            if (['%', '"', '#'].includes(cell.char)) { cell.timer--; if (cell.timer <= 0) grid[x][y] = { char: '.', color: '#444' }; }
        }
    }
    if (Math.random() < (isWetSeason ? 0.1 : 0.02)) {
        let rx = Math.floor(Math.random()*COLS), ry = Math.floor(Math.random()*ROWS);
        if (grid[rx][ry] && grid[rx][ry].char === '.') grid[rx][ry] = { char: 'y', color: '#a2d149' };
    }
}

function init() {
    for(let i=0; i<COLS; i++) for(let j=0; j<ROWS; j++) grid[i][j] = { char: '.', color: '#444' };
    for(let i=0; i<15; i++) creatures.push(new NPC(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'm', '#90ee90'));
}

window.addEventListener("keydown", (e) => { if (player) player.handleInput(e.key); });

function tick() {
    if (player) {
        if (player.standingOn && player.standingOn.char === '|') { } 
        else player.energy -= 0.6;
        document.getElementById('energy-ui').innerText = "ENERGY: " + Math.floor(player.energy);
        document.getElementById('rock-ui').innerText = "ROCKS: " + player.rocks;
        if (player.energy <= 0) player.die();
    }
    handleEnvironment(); creatures.forEach(c => c.move());
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${CELL_SIZE}px monospace`;
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let item = grid[x][y];
            if (item) {
                ctx.fillStyle = (item === player && player.standingOn && player.standingOn.char === '|') ? "#fff" : (item.color || '#2ecc71');
                ctx.fillText(item.char, x * CELL_SIZE, y * CELL_SIZE + (CELL_SIZE * 0.8));
            }
        }
    }
    setTimeout(tick, 100);
}
init(); tick();
</script>
</body>
</html>
