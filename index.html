<!DOCTYPE html>
<html>
<head>
    <style>
        body { background: #050505; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: 'Courier New', Courier, monospace; color: #b0f; }
        #main-container { display: flex; gap: 10px; border: 2px solid #442244; padding: 10px; background: #110011; }
        canvas { image-rendering: pixelated; background: #0a000a; display: block; border: 1px solid #663366; }
        #log-container { width: 260px; height: 480px; background: #000; border: 1px solid #331133; padding: 10px; font-size: 11px; overflow: hidden; display: flex; flex-direction: column-reverse; }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #220022; }
        .vulture { color: #aaaaaa; font-weight: bold; }
        .bird { color: #ffffff; }
        .death { color: #ff4444; }
    </style>
</head>
<body>

<div id="main-container">
    <canvas id="simCanvas" width="640" height="480"></canvas>
    <div id="log-container"></div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log-container');

const CELL_SIZE = 16; 
const COLS = 40; 
const ROWS = 30;

let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(null));
let creatures = [];
let eggs = [];
let birdNests = [];

const colonies = [
    {x: 4, y: 4, id: 1, color: '#ff99ff', sColor: '#ff55cc', qColor: '#ff00ff'},
    {x: COLS-5, y: ROWS-5, id: 2, color: '#99ffff', sColor: '#55ffff', qColor: '#00ffff'}
];

function addLog(text, type) {
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerText = `> ${text}`;
    logEl.prepend(entry);
    if (logEl.children.length > 25) logEl.removeChild(logEl.lastChild);
}

function isElevated(gx, gy) {
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            let nx = gx + x, ny = gy + y;
            if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                if (grid[nx][ny] && grid[nx][ny].char === 'T') return true;
            }
        }
    }
    return false;
}

class Creature {
    constructor(gx, gy, char, color, colony = null) {
        this.gx = gx; this.gy = gy;
        this.char = char; this.baseColor = color; this.color = color;
        this.colony = colony;
        this.energy = (char === 'P' || char === 'V') ? 250 : 150;
        this.isInfected = false;
        this.isImmune = false;
        this.standingOn = null;
        grid[gx][gy] = this;
    }

    move() {
        let loss = (this.char === 'P' ? 0.45 : (this.char === 'V' ? 0.4 : (this.char === 'B' ? 0.35 : 0.04)));
        if (this.isInfected) {
            this.color = "#bb00ff";
            if (['P', 'V', 'B'].includes(this.char)) loss *= 2.5;
        }

        this.energy -= loss;
        if (this.energy <= 0) return;

        let moveX = Math.floor(Math.random() * 3) - 1;
        let moveY = Math.floor(Math.random() * 3) - 1;

        // BIRD FEAR: Run from Vultures
        if (this.char === 'B') {
            let threat = this.scan(5, (i) => i.char === 'V');
            if (threat) {
                moveX = (this.gx > threat.gx ? 1 : -1);
                moveY = (this.gy > threat.gy ? 1 : -1);
            }
        }

        // HUNTING LOGIC
        if (['P', 'V', 'B'].includes(this.char)) {
            let prey = this.scan(10, (i) => {
                if (this.char === 'V') return i.char === 'B' || i.char === 'H';
                if (this.char === 'P') return ['a', 's', 'H', 'B', 'V', 'o'].includes(i.char);
                if (this.char === 'B') return i.char === 'a' || i.char === '.';
                return false;
            });
            if (prey) {
                moveX = (prey.gx > this.gx ? 1 : -1);
                moveY = (prey.gy > this.gy ? 1 : -1);
            }
        }

        let tx = Math.max(0, Math.min(COLS - 1, this.gx + moveX));
        let ty = Math.max(0, Math.min(ROWS - 1, this.gy + moveY));
        const target = grid[tx][ty];

        // FLIGHT LOGIC: B and V can fly over water/trees
        if (!['B', 'V'].includes(this.char) && target && (target.char === '~' || target.char === 'T')) {
            if (this.char === 'P' || Math.random() < 0.95) return;
        }

        if (!target || ['~', '.', 'f', '+', 'T'].includes(target.char)) {
            if (target && target.char === '+') { this.cure(); grid[tx][ty] = null; }
            this.updatePos(tx, ty, target);
        } else {
            this.handleCollision(target, tx, ty);
        }
    }

    handleCollision(target, tx, ty) {
        if (target instanceof Creature && (this.isInfected || target.isInfected) && !this.isImmune && !target.isImmune) {
            this.isInfected = true; target.isInfected = true;
        }

        let canEat = false;
        if (this.char === 'V' && ['B', 'H'].includes(target.char)) canEat = true;
        if (this.char === 'P' && ['a', 's', 'H', 'B', 'V'].includes(target.char)) canEat = true;
        if (this.char === 'B' && ['a', 'H'].includes(target.char)) canEat = true;

        if (canEat) {
            // Safety check for elevated eggs/nests (handled separately)
            if (target.standingOn && target.standingOn.char === '~' && !['B', 'V'].includes(this.char)) return;
            this.energy += 90;
            this.removeCreature(target);
            this.updatePos(tx, ty);
            if (this.char === 'V') addLog("Vulture caught a Bird", "vulture");
        }
    }

    cure() { this.isInfected = false; this.isImmune = true; this.color = "#ffff00"; }

    scan(dist, check) {
        for (let x = -dist; x <= dist; x++) {
            for (let y = -dist; y <= dist; y++) {
                let nx = this.gx + x, ny = this.gy + y;
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    let item = grid[nx][ny];
                    if (item && check(item)) return item;
                }
            }
        }
        return null;
    }

    updatePos(nx, ny, occupant) {
        grid[this.gx][this.gy] = this.standingOn || null;
        this.gx = nx; this.gy = ny;
        this.standingOn = (occupant && occupant.char !== undefined) ? occupant : null;
        if (!['B', 'V'].includes(this.char) && this.standingOn && this.standingOn.char === '~' && Math.random() < 0.3) {
            this.energy = 0; addLog(`${this.char} drowned`, 'death');
        }
        grid[this.gx][this.gy] = this;
    }

    removeCreature(obj) {
        creatures = creatures.filter(c => c !== obj);
        grid[obj.gx][obj.gy] = obj.standingOn || null;
    }
}

function spawnStatic(char, color, count) {
    for (let i = 0; i < count; i++) {
        let rx = Math.floor(Math.random() * COLS);
        let ry = Math.floor(Math.random() * ROWS);
        if (!grid[rx][ry]) grid[rx][ry] = { char, color, gx: rx, gy: ry };
    }
}

function init() {
    for(let i=0; i<70; i++) {
        let rx = Math.floor(Math.random()*COLS), ry = Math.floor(Math.random()*ROWS);
        grid[rx][ry] = {char: '~', color: '#1e90ff'};
    }
    spawnStatic('T', '#228b22', 15);
    spawnStatic('+', '#00ff00', 5);
    colonies.forEach(c => { creatures.push(new Creature(c.x, c.y, 'A', c.qColor, c)); });
    for(let i=0; i<3; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'P', '#ff4444'));
    for(let i=0; i<5; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'B', '#ffffff'));
    for(let i=0; i<2; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'V', '#aaaaaa'));
    creatures[creatures.length-1].isInfected = true;
}

function update() {
    // Bird Nesting
    creatures.forEach(c => {
        if (c.char === 'B' && c.energy > 120 && Math.random() < 0.01) {
            let tree = c.scan(2, (i) => i.char === 'T');
            if (tree) {
                let nx = tree.gx + (Math.floor(Math.random()*3)-1);
                let ny = tree.gy + (Math.floor(Math.random()*3)-1);
                if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !grid[nx][ny]) {
                    grid[nx][ny] = { char: 'n', color: '#d2b48c' };
                    birdNests.push({gx: nx, gy: ny});
                }
            }
        }
    });

    // Nest hatching
    birdNests.forEach((nest, idx) => {
        if (grid[nest.gx][nest.gy] && grid[nest.gx][nest.gy].char === 'n' && Math.random() < 0.005) {
            creatures.push(new Creature(nest.gx, nest.gy, 'B', '#ffffff'));
        }
    });

    // Respawn Vultures
    if (creatures.filter(c => c.char === 'V').length < 2 && Math.random() < 0.005) {
        creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'V', '#aaaaaa'));
    }

    // Colony growth
    colonies.forEach(col => {
        const queen = creatures.find(c => c.char === 'A' && c.colony === col);
        if (queen && queen.energy > 80 && creatures.filter(c => c.colony === col).length < 20) {
            queen.energy -= 40;
            creatures.push(new Creature(queen.gx, queen.gy, 'a', col.color, col));
        }
    });

    creatures = creatures.filter(c => {
        if (c.energy <= 0) { grid[c.gx][c.gy] = c.standingOn || null; return false; }
        c.move(); return true;
    });
    if (Math.random() < 0.1) spawnStatic('.', '#0a0', 1);
}

function tick() {
    update();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${CELL_SIZE}px monospace`;
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let item = grid[x][y];
            if (item) {
                ctx.fillStyle = item.color || '#fff';
                ctx.fillText(item.char, x * CELL_SIZE, y * CELL_SIZE + (CELL_SIZE * 0.8));
            }
        }
    }
    setTimeout(tick, 100);
}

init();
tick();
</script>
</body>
</html>
