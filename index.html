<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            background: #0a0a0a; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
            font-family: 'Courier New', Courier, monospace;
            color: #0f0;
        }
        #main-container { display: flex; gap: 10px; border: 2px solid #333; padding: 10px; background: #111; }
        #canvas-wrapper { position: relative; border: 1px solid #444; }
        canvas { image-rendering: pixelated; background: #1e1e1e; display: block; }
        #log-container {
            width: 250px; height: 480px;
            background: #000; border: 1px solid #444;
            padding: 10px; font-size: 11px; overflow: hidden;
            display: flex; flex-direction: column-reverse;
        }
        .log-entry { margin-bottom: 2px; line-height: 1.1; border-bottom: 1px solid #222; white-space: nowrap; }
        .death { color: #ff4444; }
        .event { color: #ffcc00; }
    </style>
</head>
<body>

<div id="main-container">
    <div id="canvas-wrapper">
        <canvas id="simCanvas" width="640" height="480"></canvas>
    </div>
    <div id="log-container"></div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log-container');

const CELL_SIZE = 16; 
const COLS = Math.floor(canvas.width / CELL_SIZE);
const ROWS = Math.floor(canvas.height / CELL_SIZE);

let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(null));
let creatures = [];

const colonies = [
    {x: 4, y: 4, id: 1, color: '#ff99ff', sColor: '#ff55cc', qColor: '#ff00ff'},
    {x: COLS-5, y: ROWS-5, id: 2, color: '#99ffff', sColor: '#55ffff', qColor: '#00ffff'}
];

function addLog(text, type) {
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerText = `> ${text}`;
    logEl.prepend(entry);
    if (logEl.children.length > 25) logEl.removeChild(logEl.lastChild);
}

class Creature {
    constructor(gx, gy, char, color, colony = null) {
        this.gx = gx; this.gy = gy;
        this.char = char; this.color = color;
        this.colony = colony;
        this.energy = (char === 'P') ? 180 : 100;
        grid[gx][gy] = this;
    }

    move() {
        this.energy -= (this.char === 'P' ? 0.5 : 0.25);
        let tx = this.gx;
        let ty = this.gy;

        // 1. SEEK/FLEE LOGIC
        if (this.char === 'P') {
            // Predator hunts
            let target = this.scanGrid(5, (item) => item.char === 'a' || item.char === 'H');
            if (target) {
                tx += (target.gx > this.gx ? 1 : target.gx < this.gx ? -1 : 0);
                ty += (target.gy > this.gy ? 1 : target.gy < this.gy ? -1 : 0);
            } else {
                tx += Math.floor(Math.random() * 3) - 1;
                ty += Math.floor(Math.random() * 3) - 1;
            }
        } else if (this.char === 'a' || this.char === 'H') {
            // Prey checks for danger
            let danger = this.scanGrid(3, (item) => item.char === 'P');
            if (danger) {
                // RUN AWAY: Move in opposite direction of Predator
                tx += (danger.gx > this.gx ? -1 : danger.gx < this.gx ? 1 : 0);
                ty += (danger.gy > this.gy ? -1 : danger.gy < this.gy ? 1 : 0);
            } else {
                tx += Math.floor(Math.random() * 3) - 1;
                ty += Math.floor(Math.random() * 3) - 1;
            }
        }

        tx = Math.max(0, Math.min(COLS - 1, tx));
        ty = Math.max(0, Math.min(ROWS - 1, ty));

        const occupant = grid[tx][ty];
        if (!occupant) {
            this.updatePos(tx, ty);
        } else {
            // Interaction logic
            if (this.char === 'P' && (occupant.char === 'a' || occupant.char === 'H')) {
                addLog(`Predator consumed ${occupant.char}`, 'death');
                this.energy += 70;
                this.removeCreature(occupant);
                this.updatePos(tx, ty);
            } else if (this.char === 'H' && occupant.char === '.') {
                this.energy += 40;
                grid[tx][ty] = null;
                this.updatePos(tx, ty);
            } else if (this.char === 'a' && occupant.char === 'f') {
                this.energy += 30;
                grid[tx][ty] = null;
                this.updatePos(tx, ty);
            }
        }
    }

    scanGrid(dist, criteria) {
        for (let x = -dist; x <= dist; x++) {
            for (let y = -dist; y <= dist; y++) {
                let nx = this.gx + x, ny = this.gy + y;
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    let item = grid[nx][ny];
                    if (item && criteria(item)) return item;
                }
            }
        }
        return null;
    }

    updatePos(nx, ny) {
        grid[this.gx][this.gy] = null;
        this.gx = nx; this.gy = ny;
        grid[this.gx][this.gy] = this;
    }

    removeCreature(obj) {
        creatures = creatures.filter(c => c !== obj);
        grid[obj.gx][obj.gy] = null;
    }
}

function spawnStatic(char, color, count) {
    for (let i = 0; i < count; i++) {
        let rx = Math.floor(Math.random() * COLS);
        let ry = Math.floor(Math.random() * ROWS);
        if (!grid[rx][ry]) grid[rx][ry] = { char, color };
    }
}

function init() {
    colonies.forEach(c => {
        creatures.push(new Creature(c.x, c.y, 'A', c.qColor, c));
    });
    for(let i=0; i<3; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'P', '#ff4444'));
    for(let i=0; i<12; i++) creatures.push(new Creature(Math.floor(Math.random()*COLS), Math.floor(Math.random()*ROWS), 'H', '#44ff44'));
    spawnStatic('T', '#5d4037', 15);
}

function render() {
    ctx.fillStyle = '#1e1e1e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold ${CELL_SIZE}px monospace`;
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let item = grid[x][y];
            if (item) {
                ctx.fillStyle = item.color;
                ctx.fillText(item.char, x * CELL_SIZE, y * CELL_SIZE + (CELL_SIZE * 0.8));
            }
        }
    }
}

function update() {
    // Succession & Queen Spawn
    colonies.forEach(col => {
        if (!creatures.some(c => c.char === 'A' && c.colony === col)) {
            let p = creatures.find(c => c.colony === col && c.char === 'a');
            if (p) { p.char = 'A'; p.color = col.qColor; p.energy = 150; addLog(`Queen ${col.id} replaced`, 'event'); }
        }
    });

    // Egg Laying
    creatures.forEach(c => {
        if (c.char === 'A' && c.energy > 130 && creatures.length < 120) {
            let nx = c.gx + (Math.floor(Math.random()*3)-1);
            let ny = c.gy + (Math.floor(Math.random()*3)-1);
            if (nx >=0 && nx < COLS && ny >=0 && ny < ROWS && !grid[nx][ny]) {
                creatures.push(new Creature(nx, ny, 'a', c.colony.color, c.colony));
                c.energy -= 70;
            }
        }
    });

    creatures = creatures.filter(c => {
        if (c.energy <= 0) {
            grid[c.gx][c.gy] = null;
            return false;
        }
        c.move();
        return true;
    });

    if (Math.random() < 0.2) spawnStatic('.', '#0a0', 1);
    if (Math.random() < 0.1) spawnStatic('f', '#d2b48c', 1);
}

function tick() {
    update();
    render();
    setTimeout(tick, 50);
}

init();
tick();
</script>
</body>
</html>
